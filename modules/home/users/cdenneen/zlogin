#â–ˆâ–“â–’â–‘ fake x hax
#export DISPLAY=:0
(&>/dev/null ~/.local/bin/exorg &)

#â–ˆâ–“â–’â–‘ ssh & gpg keychain init
# eval $(keychain --dir "$XDG_RUNTIME_DIR"\
# 	--absolute -q --agents gpg \
# 	--eval ~/.ssh/id_ed25519 0x3834814930B83A30 0xBFEB75D960DFAA6B)

#â–ˆâ–“â–’â–‘ 1Password + secrets management

# Helper: check if 1Password is available
has_op() {
  command -v op >/dev/null 2>&1
}

# Helper: check if at least one account is configured
has_op_accounts() {
  has_op && [ -n "$(op account list 2>/dev/null)" ]
}

# Helper: check if already unlocked
is_op_unlocked() {
  has_op_accounts && op account get >/dev/null 2>&1
}

# Unlock if needed
# if [[ $- == *i* ]]; then
#   if has_op_accounts; then
#     if ! is_op_unlocked; then
#       echo "ðŸ” Unlock your 1Password keychain:"
#       read -rs _pw
#       if [ -n "$_pw" ]; then
#         printf "Logging in: "
#         accounts=("${(f)$(op account list | tail -n +2 | sed 's/ .*//')}")
#         for acct in "${accounts[@]}"; do
#           printf "%s " "$acct"
#           eval "$(echo "$_pw" | op signin --account "$acct" 2>/dev/null)"
#         done
#         echo
#       fi
#     else
#       echo "âœ… 1Password already unlocked."
#     fi
#   fi
# fi

# Function to update secrets from 1Password
update_secrets() {
  local secrets_file="$HOME/.secrets"
  local ap="N6PZN7GSBNDJVIPTSJPHHMKVZA"
  local my="MWL6B6AUDRD77NKKKYII55VDEU"

  # Skip if op is locked or unavailable
  if ! is_op_unlocked; then
    echo "âš ï¸  1Password locked or unavailable â€” skipping secrets update."
    return
  fi

  echo "ðŸ”„ Updating secrets from 1Password..."

  {
    echo "export AZURE_DEFAULT_USERNAME=\"$(op read 'op://private/office 365/username' --account "$ap" 2>/dev/null)\""
    echo "export AZURE_DEFAULT_PASSWORD=\"$(op read 'op://private/office 365/password' --account "$ap" 2>/dev/null)\""
    echo "export GITLAB_TOKEN=\"$(op read 'op://private/gitlab personal access token/token' --account "$ap" 2>/dev/null)\""
    echo "export TF_HTTP_PASSWORD=\"$(op read 'op://private/gitlab personal access token/token' --account "$ap" 2>/dev/null)\""
    echo "export TF_HTTP_USERNAME=\"$(op read 'op://private/gitlab personal access token/username' --account "$ap" 2>/dev/null)\""
    echo "export TF_VAR_gitlab_token=\"$(op read 'op://gss/GitLab_tfadmin-cdenneen/credential' --account "$ap" 2>/dev/null)\""
    echo "export CI_REGISTRY_USER=\"$(op read 'op://Amazon Web Services/JFrog_gitlabci/username' --account "$ap" 2>/dev/null)\""
    echo "export CI_REGISTRY_PASSWORD=\"$(op read 'op://Amazon Web Services/JFrog_gitlabci/credential' --account "$ap" 2>/dev/null)\""
    echo "export GI_RENOVATE_TOKEN=\"$(op read 'op://gss/GitLab_gi-renovate/credential' --account "$ap" 2>/dev/null)\""
    echo "export RENOVATE_TOKEN=\"$(op read 'op://gss/GitLab_renovate-runner-ci/credential' --account "$ap" 2>/dev/null)\""
    echo "export DOCKER_HUB_PASSWORD=\"$(op read 'op://gss/DockerHub_token/credential' --account "$ap" 2>/dev/null)\""
    echo "export GITHUB_TOKEN=\"$(op read 'op://private/GH_TOKEN/token' --account "$my" 2>/dev/null)\""
    echo "export OPENAI_API_KEY=\"$(op read 'op://private/OpenAI/credential' --account "$ap" 2>/dev/null)\""
  } > "$secrets_file".tmp

  # Only replace if something actually changed
  if ! cmp -s "$secrets_file".tmp "$secrets_file" 2>/dev/null; then
    mv "$secrets_file".tmp "$secrets_file"
    echo "âœ… Secrets updated in $secrets_file"
  else
    rm -f "$secrets_file".tmp
    echo "âœ… Secrets already up to date."
  fi
}

# Determine the actual target of ~/.secrets
secrets_target=$(readlink ~/.secrets 2>/dev/null || echo ~/.secrets)

# If file is missing or older than 7 days, update it
if [ ! -e "$secrets_target" ] || find "$secrets_target" -mtime +7 >/dev/null 2>&1; then
  update_secrets
fi

# Load environment secrets
[ -f ~/.secrets ] && source ~/.secrets
